=head1 NAME

SQL::SyntaxModel::API_C - Describe the core C API for SQL::SyntaxModel

=head1 COPYRIGHT AND LICENSE

This file is part of the SQL::SyntaxModel library (libSQLSM).

SQL::SyntaxModel is Copyright (c) 1999-2003, Darren R. Duncan.  All rights
reserved.  Address comments, suggestions, and bug reports to
B<perl@DarrenDuncan.net>, or visit "http://www.DarrenDuncan.net" for more
information.

SQL::SyntaxModel is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License (GPL) version 2 as published
by the Free Software Foundation (http://www.fsf.org/).  You should have
received a copy of the GPL as part of the SQL::SyntaxModel distribution, in the
file named "LICENSE"; if not, write to the Free Software Foundation, Inc., 59
Temple Place, Suite 330, Boston, MA 02111-1307 USA.

Any versions of SQL::SyntaxModel that you modify and distribute must carry
prominent notices stating that you changed the files and the date of any
changes, in addition to preserving this original copyright notice and other
credits. SQL::SyntaxModel is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GPL for more details.

Linking SQL::SyntaxModel statically or dynamically with other modules is making
a combined work based on SQL::SyntaxModel.  Thus, the terms and conditions of
the GPL cover the whole combination.

As a special exception, the copyright holders of SQL::SyntaxModel give you
permission to link SQL::SyntaxModel with independent modules that are
interfaces to or implementations of databases, regardless of the license terms
of these independent modules, and to copy and distribute the resulting combined
work under terms of your choice, provided that every copy of the combined work
is accompanied by a complete copy of the source code of SQL::SyntaxModel (the
version of SQL::SyntaxModel used to produce the combined work), being
distributed under the terms of the GPL plus this exception.  An independent
module is a module which is not derived from or based on SQL::SyntaxModel, and
which is fully useable when not linked to SQL::SyntaxModel in any form.

Note that people who make modified versions of SQL::SyntaxModel are not
obligated to grant this special exception for their modified versions; it is
their choice whether to do so.  The GPL gives permission to release a modified
version without this exception; this exception also makes it possible to
release a modified version which carries forward this exception.

While it is by no means required, the copyright holders of SQL::SyntaxModel
would appreciate being informed any time you create a modified version of
SQL::SyntaxModel that you are willing to distribute, because that is a
practical way of suggesting improvements to the standard version.

=head1 DESCRIPTION

The first releases of SQL::SyntaxModel are being implemented in pure Perl 5 thanks
mainly to the heritage of original intention for using it with Perl programs,
and otherwise to the fact that Perl is great for rapid prototyping, and has a
large existing support for talking to databases, via the mature DBI framework,
upon which to build.  The longer term goal, however, is that SQL::SyntaxModel will be a
pure ANSI C library which has optional bindings for multiple other languages,
such as C++, Objective-C, Perl 5 (most importantly), Parrot and Perl 6, Python,
PHP 4+, Java, and whatever else users want.

This has practical benefits such as compatability with databases for which
there is no existing Perl support (all database drivers already have C
support), and the ability to use it with any favorite programming language
(which can bring in developers from those communities aka Parrot).  Moreover,
and most easily guessed, C is a lot more efficient in both CPU and memory
considering the huge amount of data processing that SQL::SyntaxModel has to do.  There
are good reasons for things like LIBXML, GD, and DBI to be written in C which
are applicable to SQL::SyntaxModel also.  To that end, SQL::SyntaxModel is being designed from
the ground up to be easily implemented in either Perl 5 or C, in both cases
using an object-oriented conceptual process.

This document is a reference for the SQL::SyntaxModel C API that is being planned,
consisting mainly of the C header files (struct definitions and function
declarations) that the actual SQL::SyntaxModel core will end up being.  After all,
SQL::SyntaxModel is actually more of an interface or protocol definition than an actual
implementation (although it includes those parts too).  This is intended to
give programmers an idea why the design is going the way that it is and why
details that pure Perl programs don't necessarily have to know about are being
considered.  While pure C is not object oriented at all, the SQL::SyntaxModel API is
designed to be as object-like as possible, such that each C struct for storing
data will have a corresponding set of functions for interfacing with it, and
the details for memory allocation and deallocation are handled by those also.

Note that the core libraries are intended to not have any external
dependencies, except for data type handling libraries such as for string or
sparse list handling.  These classes do not do any I/O and they do not talk to
the operating system, so they should be fully portable.  All such things are
relegated to extensions like the drivers.

Note also that the following should be considered almost-C rather than perfect
C. The reasoning is that my experience in writing C is rusty at the moment and
I haven't necessarily tried to compile these yet.  For the moment they are just
a type of documentation.  They will be improved.

=head1 CONTENT OF libSQLSM.h

	#ifndef _libSQLSM_h
	#define _libSQLSM_h

	#include "libSQLSM_types.h"
	#include "libSQLSM_tree.h"

	#endif /* _libSQLSM_h */

=head1 CONTENT OF libSQLSM_types.h

	#ifndef _libSQLSM_types_h
	#define _libSQLSM_types_h

	#ifdef __cplusplus
	extern "C" {
	#endif

	/************************************************************************/
	/* define some constant values here */

	#define FALSE 0
	#define TRUE  1

	/************************************************************************/
	/* define some simple data types here */

	typedef unsigned char dt_sqlsm_boolean; /* stores only two values: 0 (false) or 1 (true) */

	typedef unsigned char     dt_sqlsm_uint8 ; /* a precise integer between 0 and           +255 */
	typedef unsigned short    dt_sqlsm_uint16; /* a precise integer between 0 and        +65,535 */
	typedef unsigned int      dt_sqlsm_uint32; /* a precise integer between 0 and +4,294,967,295 */
	typedef unsigned longlong dt_sqlsm_uint64; /* a precise integer between 0 and      +(2^64)-1 */

	typedef char     dt_sqlsm_sint8 ; /* a precise integer between           -128 and           +127 */
	typedef short    dt_sqlsm_sint16; /* a precise integer between        -32,768 and        +32,767 */
	typedef int      dt_sqlsm_sint32; /* a precise integer between -2,147,483,648 and +2,147,483,647 */
	typedef longlong dt_sqlsm_sint64; /* a precise integer between        -(2^63) and      +(2^63)-1 */

	typedef float  dt_sqlsm_float32; /* a 32-bit imprecise fractional number */
	typedef double dt_sqlsm_float64; /* a 64-bit imprecise fractional number */

	/* a precise fractional number stored as a variable length string, up to 65K digits */
	typedef struct {
		char*           data      ;
		dt_sqlsm_uint16 used_bytes;
		dt_sqlsm_uint16 buff_bytes;
	} dt_sqlsm_decimal; 

	/* an arbitrary sized unit of binary data, up to 4 gigabytes (32-bit size count) */
	typedef struct {
		char*           data      ;
		dt_sqlsm_uint32 used_bytes;
		dt_sqlsm_uint32 buff_bytes;
	} dt_sqlsm_binary32; 

	/* an arbitrary sized unit of binary data, up to 16 exabytes (64-bit size count) */
	typedef struct {
		char*           data      ;
		dt_sqlsm_uint64 used_bytes;
		dt_sqlsm_uint64 buff_bytes;
	} dt_sqlsm_binary64; 

	/* enumeration of character encoding types */
	typedef enum { 
		SQLSM_STR_ENC_U8 , /* 8-bit unicode  */
		SQLSM_STR_ENC_U16, /* 16-bit unicode */
		SQLSM_STR_ENC_U32, /* 32-bit unicode */
		SQLSM_STR_ENC_ASC, /* 8-bit ascii    */
		SQLSM_STR_ENC_EBS  /* 8-bit ebsdic   */
	} en_sqlsm_str_enc_type; 

	/* an arbitrary sized unit of text data that is not null terminated, up to 4 gigabytes */
	typedef struct {
		char*                 data      ; /* actual string data, which may contain nulls */
		dt_sqlsm_uint32       used_bytes; /* size of memory used by data in bytes */
		dt_sqlsm_uint32       buff_bytes; /* max size of contiguous memory data could grow into */
		en_sqlsm_str_enc_type enc_type  ; /* string encoding type that data is using */
	} dt_sqlsm_string32; 

	/* an arbitrary sized unit of text data that is not null terminated, up to 16 exabytes */
	typedef struct {
		char*                 data      ; /* actual string data, which may contain nulls */
		dt_sqlsm_uint64       used_bytes; /* size of memory used by data in bytes */
		dt_sqlsm_uint64       buff_bytes; /* max size of contiguous memory data could grow into */
		en_sqlsm_str_enc_type enc_type  ; /* string encoding type that data is using */
	} dt_sqlsm_string64; 

	/* a date and time (whose representation isn't decided yet) */
	typedef struct {
		char*          data      ;
		dt_sqlsm_uint8 used_bytes;
		dt_sqlsm_uint8 buff_bytes;
	} dt_sqlsm_datetime; 

	/************************************************************************/
	/* define some accessor functions here */

	/************************************************************************/

	#ifdef __cplusplus
	}
	#endif

	#endif /* _libSQLSM_types_h */

=head1 CONTENT OF libSQLSM_tree.h

	#ifndef _libSQLSM_tree_h
	#define _libSQLSM_tree_h

	#ifdef __cplusplus
	extern "C" {
	#endif

	#include "libSQLSM_types.h"

	/************************************************************************/
	/* define some simple data types here */

	/* enumeration of basic data types */
	typedef enum { 
		BIN,     /* binary data */
		STR,     /* text data */
		NUM,     /* a number, either integral or fractional */
		BOOL,    /* a boolean */
		DATETIME /* a date and time; this may be split into more types */
		/* may add geographical types */
		/* may add enumerated or set types */
	} en_sqlsm_datatype_base; 

	/* enumeration of ways to handle latin character data */
	typedef enum { 
		PRESERVE, /* preserve existing case, upper and lower */
		TOUPPER,  /* convert to upper case */
		TOLOWER   /* convert to lower case */
	} en_sqlsm_datatype_case; 

	/* meta-data for a scalar unit of data, such as a db table column */
	typedef struct {
		dt_sqlsm_string32      name          ; /* unique user-readable data type */
		en_sqlsm_datatype_base base_type     ; /* basic underlying data type */
		dt_sqlsm_uint64        size          ; /* in bytes for BIN, STR, NUM */
		dt_sqlsm_boolean       store_fixed   ; /* true = try to store fixed size; default is var size */
		en_sqlsm_str_enc_type  str_encoding  ; /* string encoding type for STR data */
		dt_sqlsm_boolean       str_trim_white; /* true = trim bounding whitespace on save */
		en_sqlsm_datatype_case str_latin_case; /* says how to handle latin text case on save */
		dt_sqlsm_string32      str_pad_char  ; /* if def, use char to pad fixed-width strs on save */
		dt_sqlsm_boolean       str_trim_pad  ; /* true = trim padding of fixed-width strs on read */
		dt_sqlsm_boolean       int_unsigned  ; /* true = only INTs >= 0 can be stored */
		dt_sqlsm_uint16        dec_precision ; /* allowed max prec for DEC nums; must be < size */
		/* others may be added such as min/max allowed num or date values or which calendar to use */
	} st_sqlsm_datatype; 

	/************************************************************************/
	/* define some accessor functions here */

	/************************************************************************/

	#ifdef __cplusplus
	}
	#endif

	#endif /* _libSQLSM_tree_h */

=head1 SEE ALSO

perl(1), SQL::SyntaxModel, SQL::SyntaxModel::DataDictionary,
SQL::SyntaxModel::XMLSchema, Rosetta, Rosetta::Framework.

=cut
